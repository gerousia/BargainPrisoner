##############################
## Modified Vanilla on_actions
##############################

## From ./common/on_action/prison_on_actions.txt
# Code on-action: character released from prison in root scope. Does not fire when "released" due to dying
# imprisoning character set as scope:imprisoner
on_release_from_prison = {
	effect = {

		if = {
			# Uses flag to stop multiple memories from generating with released_from_prison_memory
			limit = { 
				NOT = { has_character_flag = escaped_from_prison_flag } 
				NOT = { has_character_flag = under_offer_as_prisoner_flag }
			}
			create_character_memory = {
				type = released_from_prison_memory
				participants = {
					imprisoner = scope:imprisoner
				}
			}
		}

		# From TP - Prisoner is under offer as prisoner to another ruler
		#if = {
		#	limit = { has_character_flag = under_offer_as_prisoner_flag }
		#	remove_character_flag = under_offer_as_prisoner_flag
		#}

		# From FP1 - Prisoner is designated as a human sacrifice
		if = {
			limit = { has_character_modifier = gruesome_festivals_designated_sacrifice_fp1_modifier }
			remove_character_modifier = gruesome_festivals_designated_sacrifice_fp1_modifier
		}
		
		# From Event hold_court.6140
		if = {
			limit = { has_character_modifier = 6140_animal_guardian_modifier }
			remove_character_modifier = 6140_animal_guardian_modifier
		}

		# Prisoner is Realm Priest
		if = {
			limit = { has_character_flag = realm_priest }
			remove_character_flag = realm_priest
		}

		# Prisoner has a rival
		if = {
			limit = { has_character_flag = rival_on_exit_prison	}
			remove_character_flag = rival_on_exit_prison

			# imprisoner has to still be valid and alive
			if = {
				limit = { scope:imprisoner ?= { is_alive = yes } }
				set_relation_rival = {
					target = scope:imprisoner
					reason = rival_was_kept_in_jail
				}
			}
		}

		# Prisoner was imprisoned by Diarch
		if = {
			limit = { has_variable = imprisoned_by_diarch }
			remove_variable = imprisoned_by_diarch
		}
	}

	events = {
		prison.0001					# Remove imprisoned_me modifier, consume imprisonment reasons the imprisoner had
		prison_notification.2001
		intrigue_dread.4010			# Interrupts this event chain for the imprisoner when their prisoner is freed.
		human_sacrifice.0003		# Is the character marked for human sacrifice?
		martial_authority.2054 		# Right-hand wo/man released 
	}
}


##############################
## TP Prisoner on_actions
##############################

# Called when the prisoner departs from the actor
# root = prisoner_from_sender
on_prisoner_company_depart_for_recipient = {
	# memory depart from sender
	# negative opinions for being traded as a prisoner
	effect = {
		var:prison_guard_travelling_with_prisoner ?= { 
			save_scope_as = prison_guard 
		}

		current_travel_plan ?= {
			# Only the prisoner and their bodyguard is allowed in this travel plan
			every_entourage_character = {
				remove_character = this
				#set_location_to_default = yes
			}
			set_travel_leader = scope:prison_guard
		}
	}
}

# Called when the prisoner travel gets cancelled
# root = prisoner_from_sender
on_prisoner_company_depart_travel_planner_exit = {
	effect = {
		# Invalidated travelling prisoner
		prisoner_travel_company_remove_effect = yes
	}
}

# Called when the prisoner arrives at the recipient.
# root = secondary_actor
# scope:sender = actor
# scope:reciever = recipient
# scope:prisoner_from_sender = secondary_actor
on_prisoner_company_arrive_at_recipient = {
	effect = {
		var:prison_guard_travelling_with_prisoner ?= { 
			save_scope_as = prison_guard 
		}

		# Invalidation Check.
		## Bodyguard.
		if = {
			limit = { 
				var:prison_guard_travelling_with_prisoner = {
					OR = {
						is_alive = no
						is_imprisoned = yes
						NOT = { has_court_position = bodyguard_court_position } 
					}
				}
			}
			root = {
				set_variable = {
					name = invalidation_reason
					value = flag:bodyguard
				}
			}
		}
		## Recipient.
		else_if = {
			limit = {
				scope:reciever = {
					OR = {
						is_alive = no 
						#is_landed = no 
						#is_imprisoned = no
					}
				}
			}
			root = {
				set_variable = {
					name = invalidation_reason
					value = flag:receiver
				}
			}
			debug_log = "passed here"
		}

		# Invalidate travelling prisoner.
		if = {
			limit = { has_variable = invalidation_reason }
			trigger_event = { on_action = on_prisoner_company_invalidated }
		}
		# But If everything goes well...
		else = {
			scope:reciever = { trigger_event = tp_prisoner_system.0001 }
			# If bodyguard is still present, bodyguard travels back alone to their liege.
			var:prison_guard_travelling_with_prisoner ?= { travel_back_home = yes }
		}
		
		# Remove flags/variables related to the prisoners and bodyguards.
		prisoner_travel_company_remove_effect = yes

		## Opinion Modifiers/Events related to prisoner transfer below
		# - - - - -
	}
}

# Called when the prisoner travel gets invalidated
# root = prisoner_from_sender
# var:invalidation_reason is the reason for invalidation
## var:invalidation_reason = flag:death 		- The bodyguard accompanying the prisoner is dead
## var:invalidation_reason = flag:deposed 		- The bodyguard accompanying the prisoner is deposed
## var:invalidation_reason = flag:imprisoned 	- The bodyguard accompanying the prisoner is imprisoned
## var:invalidation_reason = flag:reciever 	- The recipient is either dead, unlanded, or imprisoned
## var:invalidation_reason = flag:invalid 		- The fallback invalidation
on_prisoner_company_invalidated = {
	effect = {
		#var:invalidation_reason = { save_temporary_scope_as = reason }

		# Invalidated travelling prisoner
		if = {
			limit = { has_variable = invalidation_reason }
			# Notify actors.
			## Death.
			if = {
				limit = { var:invalidation_reason = flag:death }
				### Notify the liege.
				scope:sender = {
					send_interface_toast = {
						title = prisoner_invalidated_during_travel_toast
						left_icon = scope:prisoner_from_sender
						right_icon = scope:reciever
						desc = prisoner_invalidated_during_travel.liege.death.desc
					}
				}
				### Notify the recipient.
				scope:reciever = {
					send_interface_toast = {
						title = prisoner_invalidated_during_travel_toast
						left_icon = scope:prisoner_from_sender
						right_icon = scope:sender
						desc = prisoner_invalidated_during_travel.recipient.death.desc
					}
				}
			}
			## Deposition.
			else_if = {
				limit = { var:invalidation_reason = flag:depose }
				### Notify the liege.
				scope:sender = {
					send_interface_toast = {
						title = prisoner_invalidated_during_travel_toast
						left_icon = scope:prisoner_from_sender
						right_icon = scope:reciever
						desc = prisoner_invalidated_during_travel.liege.deposed.desc
					}
				}
				### Notify the recipient.
				scope:reciever = {
					send_interface_toast = {
						title = prisoner_invalidated_during_travel_toast
						left_icon = scope:prisoner_from_sender
						right_icon = scope:sender
						desc = prisoner_invalidated_during_travel.recipient.deposed.desc
					}
				}
			}
			## Bodyguard.
			else_if = {
				limit = { var:invalidation_reason = flag:bodyguard }
				### Notify the liege.
				scope:sender = {
					send_interface_toast = {
						title = prisoner_invalidated_during_travel_toast
						left_icon = scope:prisoner_from_sender
						right_icon = scope:reciever
						custom_tooltip = prisoner_invalidated_during_travel.liege.bodyguard.tt
					}
					root = { save_scope_as = escapee }
					trigger_event =  tp_prison.9000
				}
				### Notify the recipient.
				scope:reciever = {
					send_interface_toast = {
						title = prisoner_invalidated_during_travel_toast
						left_icon = scope:prisoner_from_sender
						right_icon = scope:sender
						custom_tooltip = prisoner_invalidated_during_travel.recipient.bodyguard.tt
					}
				}
			}
			## Recipient.
			else_if = {
				limit = { var:invalidation_reason = flag:reciever }
				### Notify the liege.
				scope:sender = {
					send_interface_toast = {
						title = prisoner_invalidated_during_travel_toast
						left_icon = scope:prisoner_from_sender
						right_icon = scope:reciever
						custom_tooltip = prisoner_invalidated_during_travel.liege.reciever.desc
					}
				}
				### Notify the recipient.
				scope:reciever = {
					send_interface_toast = {
						title = prisoner_invalidated_during_travel_toast
						left_icon = scope:prisoner_from_sender
						right_icon = scope:sender
						custom_tooltip = prisoner_invalidated_during_travel.recipient.reciever.tt
					}
				}
			}
			## Invalidation.
			else_if = {
				limit = { var:invalidation_reason = flag:invalid }
				### Notify the liege.
				scope:sender = {
					send_interface_toast = {
						title = prisoner_invalidated_during_travel_toast
						left_icon = scope:prisoner_from_sender
						right_icon = scope:reciever
						desc = prisoner_invalidated_during_travel.liege.deposed.desc
					}
				}
				### Notify the recipient.
				scope:reciever = {
					send_interface_toast = {
						title = prisoner_invalidated_during_travel_toast
						left_icon = scope:prisoner_from_sender
						right_icon = scope:sender
						desc = prisoner_invalidated_during_travel.recipient.deposed.desc
					}
				}
			}
			## If Prisoner hasn't already escaped, get a chance to do so.
			if = {
				limit = { 
					NOR = { 
						var:invalidation_reason = flag:reciever
						var:invalidation_reason = flag:escaped
					} 
				}
				release_from_prison = yes
				#travel_back_home = yes 
				#trigger_event = { id = prison.9499 }
				scope:sender = {
					send_interface_toast = {
						title = "tumakas gago"
					}
				}
			}

			scope:sender = {
				send_interface_toast = {
					title = "putangina"
				}
			}

			## If bodyguard is still present, bodyguard travels back alone to their liege.
			var:prison_guard_travelling_with_prisoner ?= { travel_back_home = yes }
		}
		# If the prisoner didn't escape, then prisoner travels back to their imprisoner.
		else = {
			if = {
				var:prison_guard_travelling_with_prisoner ?= { 
					save_temporary_scope_as = prison_guard 
				}

				limit = { NOT = { location = imprisoner.capital_province } }
				start_travel_plan = {
					players_use_planner = no
					destination = imprisoner.capital_province
					companion = scope:prison_guard
					on_start_on_action = on_prisoner_company_depart_for_imprisoner
					return_trip = no
				}
			}
		}
		# Remove flags/variables related to the prisoners and bodyguards.
		prisoner_travel_company_remove_effect = yes
	}
}

# Called when the prisoner departs for the actor
# root = prisoner_from_sender
on_prisoner_company_depart_for_imprisoner = {
	effect = {
		current_travel_plan ?= {
			# Only the prisoner and their bodyguard is allowed in this travel plan
			every_entourage_character = { remove_character = this }
			set_travel_leader = prison_guard
		}
	}
}